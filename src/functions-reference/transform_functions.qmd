---
pagetitle: Variable Transformation Functions
---

# Variable Transformation Functions

These functions provide direct access to the ability to
constrain and unconstrain variables using the built-in transformations
as defined in the [Stan Reference Manual](https://mc-stan.org/docs/reference-manual/transforms.html).

For each of the built-in variable transforms, there are 3 functions exposed. A
`_constrain` function that maps from free variables to constrained variables (the "inverse transform"),
a `_unconstrain` function that maps from the constrained space back to free variables (the "transform"),
and a [`_jacobian` function](https://mc-stan.org/docs/reference-manual/statements.html#increment-log-density-with-a-change-of-variables-adjustment),
which computes the same value as the `_constrain` function while also
incrementing the target with the relevant change of variables adjustment.

For this page, variables named `y` are unconstrained, while variables named `x`
are in the constrained space. The unconstraining functions will cause rejections
if their input is not properly in the constrained space.

## Transforms for scalars

These transformations take unconstrained values on the real number line and
either restrict them to part of it or shift and scale their values.
Note: It is possible to use these transforms with arrays and other containers like `vector`s.
This results in elementwise application of the transform. If the `y` argument is
a container, the others must be either scalars or containers of exactly the same size.

### Lower bounds

These functions perform the mathematical transform described in the
[Lower Bounded Scalar section](https://mc-stan.org/docs/reference-manual/transforms.html#lower-bound-transform.section).

<!-- reals; lower_bound_constrain; (reals y, reals l); -->
\index{{\tt \bfseries lower\_bound\_constrain }!{\tt (reals y, reals l): reals}|hyperpage}

`reals` **`lower_bound_constrain`**`(reals y, reals l)`<br>\newline
Takes a value `y` and lower bound `l` and returns a corresponding value
which is greater than `l` (except for the possibility of numeric precision issues).

{{< since 2.37 >}}

<!-- reals; lower_bound_jacobian; (reals y, reals l); -->
\index{{\tt \bfseries lower\_bound\_jacobian }!{\tt (reals y, reals l): reals}|hyperpage}

`reals` **`lower_bound_jacobian`**`(reals y, reals l)`<br>\newline
Takes a value `y` and lower bound `l` and returns a corresponding value
which is greater than `l` (except for the possibility of numeric precision issues).

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- reals; lower_bound_unconstrain; (reals x, reals l); -->
\index{{\tt \bfseries lower\_bound\_unconstrain }!{\tt (reals x, reals l): reals}|hyperpage}

`reals` **`lower_bound_unconstrain`**`(reals x, reals l)`<br>\newline
Takes a value `x` which is greater than `l` and returns the corresponding
unconstrained value.
{{< since 2.37 >}}

### Upper bounds

These functions perform the mathematical transform described in the
[Upper Bounded Scalar section](https://mc-stan.org/docs/reference-manual/transforms.html#upper-bounded-scalar).

<!-- reals; upper_bound_constrain; (reals y, reals u); -->
\index{{\tt \bfseries upper\_bound\_constrain }!{\tt (reals y, reals u): reals}|hyperpage}

`reals` **`upper_bound_constrain`**`(reals y, reals u)`<br>\newline
Takes a value `y` and upper bound `u` and returns a corresponding value
which is less than `u` (except for the possibility of numeric precision issues).
{{< since 2.37 >}}

<!-- reals; upper_bound_jacobian; (reals x, reals u); -->
\index{{\tt \bfseries upper\_bound\_jacobian }!{\tt (reals x, reals u): reals}|hyperpage}

`reals` **`upper_bound_jacobian`**`(reals x, reals u)`<br>\newline
Takes a value `y` and upper bound `u` and returns a corresponding value
which is less than `u` (except for the possibility of numeric precision issues).

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- reals; upper_bound_unconstrain; (reals x, reals u); -->
\index{{\tt \bfseries upper\_bound\_unconstrain }!{\tt (reals x, reals u): reals}|hyperpage}

`reals` **`upper_bound_unconstrain`**`(reals x, reals u)`<br>\newline
Takes a value `x` which is less than `u` and returns the corresponding
unconstrained value.
{{< since 2.37 >}}

### Upper and lower bounds

These functions perform the mathematical transform described in the
[Lower and Upper Bounded Scalar section](https://mc-stan.org/docs/reference-manual/transforms.html#logit-transform-jacobian.section).

<!-- reals; lower_upper_bound_constrain; (reals y, reals l, reals u); -->
\index{{\tt \bfseries lower\_upper\_bound\_constrain }!{\tt (reals y, reals l, reals u): reals}|hyperpage}

`reals` **`lower_upper_bound_constrain`**`(reals y, reals l, reals u)`<br>\newline
Takes a value `y`, lower bound `l`, and upper bound `u` and returns a corresponding value
which is bounded between `l` and `u` (except for the possibility of numeric precision issues).
{{< since 2.37 >}}

<!-- reals; lower_upper_bound_jacobian; (reals y, reals l, reals u); -->
\index{{\tt \bfseries lower\_upper\_bound\_jacobian }!{\tt (reals y, reals l, reals u): reals}|hyperpage}

`reals` **`lower_upper_bound_jacobian`**`(reals y, reals l, reals u)`<br>\newline
Takes a value `y`, lower bound `l`, and upper bound `u` and returns a corresponding value
which is bounded between `l` and `u` (except for the possibility of numeric precision issues).

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}
<!-- reals; lower_upper_bound_unconstrain; (reals x, reals l, reals y); -->
\index{{\tt \bfseries lower\_upper\_bound\_unconstrain }!{\tt (reals x, reals l, reals y): reals}|hyperpage}

`reals` **`lower_upper_bound_unconstrain`**`(reals x, reals l, reals y)`<br>\newline
Takes a value `x` which is bounded between `l` and `u` and returns returns the corresponding
unconstrained value.
{{< since 2.37 >}}

### Affine transforms

These functions perform the mathematical transform described in the
[Affinely Transformed Scalar section](https://mc-stan.org/docs/reference-manual/transforms.html#affinely-transformed-scalar).

<!-- reals; offset_multiplier_constrain; (reals y, reals offset, reals mult); -->
\index{{\tt \bfseries offset\_multiplier\_constrain }!{\tt (reals y, reals offset, reals mult): reals}|hyperpage}

`reals` **`offset_multiplier_constrain`**`(reals y, reals offset, reals mult)`<br>\newline
Takes a value `y`, shift `offset`, and scale `mult` and returns a shifted
and re-scaled value.
{{< since 2.37 >}}

<!-- reals; offset_multiplier_jacobian; (reals y, reals offset, reals mult); -->
\index{{\tt \bfseries offset\_multiplier\_jacobian }!{\tt (reals y, reals offset, reals mult): reals}|hyperpage}

`reals` **`offset_multiplier_jacobian`**`(reals y, reals offset, reals mult)`<br>\newline
Takes a value `y`, shift `offset`, and scale `mult` and returns a shifted
and re-scaled value.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- reals; offset_multiplier_unconstrain; (reals x, reals offset, reals mult); -->
\index{{\tt \bfseries offset\_multiplier\_unconstrain }!{\tt (reals x, reals offset, reals mult): reals}|hyperpage}

`reals` **`offset_multiplier_unconstrain`**`(reals x, reals offset, reals mult)`<br>\newline
Takes a value `x`, shift `offset`, and scale `mult` and a value which has been un-scaled
and un-shifted.
{{< since 2.37 >}}

## Transforms for constrained vectors

These functions constrain entire vectors. Note that
this ocassionally leads to a change in length, which will be
noted in the documentation for the relevant functions.

Where `vectors` is used, this indicates that either a `vector`
or a (possibly multidimensional) array of `vector`s may be
provided. The array will be processed element by element.

### Ordered vectors

These functions perform the mathematical transform described in the
[Ordered Vector section](https://mc-stan.org/docs/reference-manual/transforms.html#ordered-vector).

<!-- vectors; ordered_constrain; (vectors y); -->
\index{{\tt \bfseries ordered\_constrain }!{\tt (vectors y): vectors}|hyperpage}

`vectors` **`ordered_constrain`**`(vectors y)`<br>\newline
Takes a free vector `y` and returns a vector such that each element is smaller
than the next.
{{< since 2.37 >}}

<!-- vectors; ordered_jacobian; (vectors y); -->
\index{{\tt \bfseries ordered\_jacobian }!{\tt (vectors y): vectors}|hyperpage}

`vectors` **`ordered_jacobian`**`(vectors y)`<br>\newline
Takes a free vector `y` and returns a vector such that each element is smaller
than the next.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- vectors; ordered_unconstrain; (vectors x); -->
\index{{\tt \bfseries ordered\_unconstrain }!{\tt (vectors x): vectors}|hyperpage}

`vectors` **`ordered_unconstrain`**`(vectors x)`<br>\newline
Takes an ordered vector `x` and returns the corresponding free vector.
{{< since 2.37 >}}

### Positive order vectors

These functions perform the mathematical transform described in the
[Positive Ordered Vector section](https://mc-stan.org/docs/reference-manual/transforms.html#positive-ordered-vector).

<!-- vectors; positive_ordered_constrain; (vectors y); -->
\index{{\tt \bfseries positive\_ordered\_constrain }!{\tt (vectors y): vectors}|hyperpage}

`vectors` **`positive_ordered_constrain`**`(vectors y)`<br>\newline
Takes a free vector `y` and returns a vector such that each element is positive and
smaller than its successor.
{{< since 2.37 >}}

<!-- vectors; positive_ordered_jacobian; (vectors y); -->
\index{{\tt \bfseries positive\_ordered\_jacobian }!{\tt (vectors y): vectors}|hyperpage}

`vectors` **`positive_ordered_jacobian`**`(vectors y)`<br>\newline
Takes a free vector `y` and returns a vector such that each element is positive and
smaller than its successor.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- vectors; positive_ordered_unconstrain; (vectors x); -->
\index{{\tt \bfseries positive\_ordered\_unconstrain }!{\tt (vectors x): vectors}|hyperpage}

`vectors` **`positive_ordered_unconstrain`**`(vectors x)`<br>\newline
Takes an ordered vector `x` with positive entries and returns the corresponding free vector.
{{< since 2.37 >}}

### Simplices

These functions perform the mathematical transform described in the
[Unit Simplex section](https://mc-stan.org/docs/reference-manual/transforms.html#simplex-transform.section).

<!-- vectors; simplex_constrain; (vectors y); -->
\index{{\tt \bfseries simplex\_constrain }!{\tt (vectors y): vectors}|hyperpage}

`vectors` **`simplex_constrain`**`(vectors y)`<br>\newline
Takes a free vector `y` and returns a simplex (a vector such that each element
is between `0` and `1`, and the sum of the elements is `1`).

This returned vector will have one extra element compared to the input `y`.
{{< since 2.37 >}}

<!-- vectors; simplex_jacobian; (vectors y); -->
\index{{\tt \bfseries simplex\_jacobian }!{\tt (vectors y): vectors}|hyperpage}

`vectors` **`simplex_jacobian`**`(vectors y)`<br>\newline
Takes a free vector `y` and returns a simplex (a vector such that each element
is between `0` and `1`, and the sum of the elements is `1`).

This returned vector will have one extra element compared to the input `y`.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- vectors; simplex_unconstrain; (vectors x); -->
\index{{\tt \bfseries simplex\_unconstrain }!{\tt (vectors x): vectors}|hyperpage}

`vectors` **`simplex_unconstrain`**`(vectors x)`<br>\newline
Takes a simplex `x` and returns the corresponding free vector.

This returned vector will have one fewer elements compared to the input `x`.
{{< since 2.37 >}}

### Zero-sum vectors

These functions perform the mathematical transform described in the
[Zero Sum Vector section](https://mc-stan.org/docs/reference-manual/transforms.html#zero-sum-vector).

<!-- vectors; sum_to_zero_constrain; (vectors y); -->
\index{{\tt \bfseries sum\_to\_zero\_constrain }!{\tt (vectors y): vectors}|hyperpage}

`vectors` **`sum_to_zero_constrain`**`(vectors y)`<br>\newline
Takes a free vector `y` and returns a vector such that the elements
sum to `0`.

This returned vector will have one extra element compared to the input `y`.
{{< since 2.37 >}}

<!-- vectors; sum_to_zero_jacobian; (vectors y); -->
\index{{\tt \bfseries sum\_to\_zero\_jacobian }!{\tt (vectors y): vectors}|hyperpage}

`vectors` **`sum_to_zero_jacobian`**`(vectors y)`<br>\newline
Takes a free vector `y` and returns a vector such that the elements
sum to `0`.

The returned vector will have one extra element compared to the input `y`.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- vectors; sum_to_zero_unconstrain; (vectors x); -->
\index{{\tt \bfseries sum\_to\_zero\_unconstrain }!{\tt (vectors x): vectors}|hyperpage}

`vectors` **`sum_to_zero_unconstrain`**`(vectors x)`<br>\newline
Takes a vector `x` with elements that sum to `0` and returns the
corresponding free vector.

This returned vector will have one fewer elements compared to the input `x`.
{{< since 2.37 >}}

### Unit vectors

These functions perform the mathematical transform described in the
[Unit Vector section](https://mc-stan.org/docs/reference-manual/transforms.html#unit-vector.section).

<!-- vectors; unit_vectors_constrain; (vectors y); -->
\index{{\tt \bfseries unit\_vectors\_constrain }!{\tt (vectors y): vectors}|hyperpage}

`vectors` **`unit_vectors_constrain`**`(vectors y)`<br>\newline
Takes a free vector `y` and returns a vector with Euclidian length `1`, e.g.
`norm2(unit_vectors_constrain(y)) == 1` for any `y` that has a positive
and finite norm itself. Note that, in particular, this function rejects
if given a vector of all zeros.
{{< since 2.37 >}}

<!-- vectors; unit_vectors_jacobian; (vectors y); -->
\index{{\tt \bfseries unit\_vectors\_jacobian }!{\tt (vectors y): vectors}|hyperpage}

`vectors` **`unit_vectors_jacobian`**`(vectors y)`<br>\newline
Takes a free vector `y` and returns a vector with Euclidian length `1`.
This function rejects if given a vector of all zeros.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- vectors; unit_vectors_unconstrain; (vectors x); -->
\index{{\tt \bfseries unit\_vectors\_unconstrain }!{\tt (vectors x): vectors}|hyperpage}

`vectors` **`unit_vectors_unconstrain`**`(vectors x)`<br>\newline
Takes a vector `x` of unit length and returns the corresponding free vector.
{{< since 2.37 >}}

## Transforms for constrained matrices

Similarly to the above, `vectors` means a `vector` or array thereof,
and `matrices` means a `matrix` or array thereof.

### Cholesky factors of correlation matrices


These functions perform the mathematical transform described in the
[Cholesky Factors of Correlation Matrices section](https://mc-stan.org/docs/reference-manual/transforms.html#cholesky-factors-of-correlation-matrices).

<!-- matrices; cholesky_factor_corr_constrain; (vectors y, int K); -->
\index{{\tt \bfseries cholesky\_factor\_corr\_constrain }!{\tt (vectors y, int K): matrices}|hyperpage}

`matrices` **`cholesky_factor_corr_constrain`**`(vectors y, int K)`<br>\newline
Takes a vector `y` and integer `K`, where `length(y) == choose(K, 2)`, and returns
a `K` by `K` Cholesky factor of a correlation matrix.
{{< since 2.37 >}}

<!-- matrices; cholesky_factor_corr_jacobian; (vectors y, int K); -->
\index{{\tt \bfseries cholesky\_factor\_corr\_jacobian }!{\tt (vectors y, int K): matrices}|hyperpage}
Takes a vector `y` and integer `K`, where `length(y) == choose(K, 2)`, and returns
a `K` by `K` Cholesky factor of a correlation matrix.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
`matrices` **`cholesky_factor_corr_jacobian`**`(vectors y, int K)`<br>\newline

{{< since 2.37 >}}

<!-- vectors; cholesky_factor_corr_unconstrain; (matrices x); -->
\index{{\tt \bfseries cholesky\_factor\_corr\_unconstrain }!{\tt (matrices x): vectors}|hyperpage}

`vectors` **`cholesky_factor_corr_unconstrain`**`(matrices x)`<br>\newline
Takes `x`, a lower triangular square ($K$ by $K$) matrix which is the Cholesky factor of a correlation matrix,
and returns a corresponding free vector of length $K\choose 2$.
{{< since 2.37 >}}

### Cholesky factors of covariance matrices

These functions perform the mathematical transform described in the
[Cholesky Factors of Covariance Matrices section](https://mc-stan.org/docs/reference-manual/transforms.html#cholesky-factors-of-covariance-matrices).

<!-- matrices; cholesky_factor_cov_constrain; (vectors y, int M, int N); -->
\index{{\tt \bfseries cholesky\_factor\_cov\_constrain }!{\tt (vectors y, int M, int N): matrices}|hyperpage}

`matrices` **`cholesky_factor_cov_constrain`**`(vectors y, int M, int N)`<br>\newline
Takes a free vector `y` and integers `M` and `N` and returns the `M` by `N` Cholesky
factor of a covariance matrix. Note that `y` must have length `N + choose(N, 2) + (M - N) * N`,
and `M` must be greater than or equal to `N`.
{{< since 2.37 >}}

<!-- matrices; cholesky_factor_cov_jacobian; (vectors y, int M, int N); -->
\index{{\tt \bfseries cholesky\_factor\_cov\_jacobian }!{\tt (vectors y, int M, int N): matrices}|hyperpage}

`matrices` **`cholesky_factor_cov_jacobian`**`(vectors y, int M, int N)`<br>\newline
Takes a free vector `y` and integers `M` and `N` and returns the `M` by `N` Cholesky
factor of a covariance matrix. Note that `y` must have length `N + choose(N, 2) + (M - N) * N`,
and `M` must be greater than or equal to `N`.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- vectors; cholesky_factor_cov_unconstrain; (matrices x); -->
\index{{\tt \bfseries cholesky\_factor\_cov\_unconstrain }!{\tt (matrices x): vectors}|hyperpage}

`vectors` **`cholesky_factor_cov_unconstrain`**`(matrices x)`<br>\newline
Takes a $M$ by $N$ Cholesky factor of a covariance matrix `x` and returns
the corresponding free vector of length $N + N\choose 2 + (M - N)N$.

{{< since 2.37 >}}

### Correlation matrices

These functions perform the mathematical transform described in the
[Correlation Matrices section](https://mc-stan.org/docs/reference-manual/transforms.html#correlation-matrix-transform.section).

<!-- matrices; corr_matrix_constrain; (vectors y, int K); -->
\index{{\tt \bfseries corr\_matrix\_constrain }!{\tt (vectors y, int K): matrices}|hyperpage}

`matrices` **`corr_matrix_constrain`**`(vectors y, int K)`<br>\newline
Takes a vector `y` and integer `K`, where `length(y) == choose(K, 2)`, and returns
a `K` by `K` correlation matrix.
{{< since 2.37 >}}

<!-- matrices; corr_matrix_jacobian; (vectors y, int K); -->
\index{{\tt \bfseries corr\_matrix\_jacobian }!{\tt (vectors y, int K): matrices}|hyperpage}

`matrices` **`corr_matrix_jacobian`**`(vectors y, int K)`<br>\newline
Takes a vector `y` and integer `K`, where `length(y) == choose(K, 2)`, and returns
a `K` by `K` correlation matrix.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- vectors; corr_matrix_unconstrain; (matrices x); -->
\index{{\tt \bfseries corr\_matrix\_unconstrain }!{\tt (matrices x): vectors}|hyperpage}

`vectors` **`corr_matrix_unconstrain`**`(matrices x)`<br>\newline
Takes a $K$ by $K$ correlation matrix `x` and returns the corresponding
free vector of size $K\choose 2$.
{{< since 2.37 >}}

### Covariance matrices

These functions perform the mathematical transform described in the
[Covariance Matrices section](https://mc-stan.org/docs/reference-manual/transforms.html#covariance-matrices).

<!-- matrices; cov_matrix_constrain; (vectors y, int K); -->
\index{{\tt \bfseries cov\_matrix\_constrain }!{\tt (vectors y, int K): matrices}|hyperpage}

`matrices` **`cov_matrix_constrain`**`(vectors y, int K)`<br>\newline
Takes a vector `y` and integer `K`, where `length(y) == K + choose(K, 2)`, and returns
a `K` by `K` covariance matrix.
{{< since 2.37 >}}

<!-- matrices; cov_matrix_jacobian; (vectors y, int K); -->
\index{{\tt \bfseries cov\_matrix\_jacobian }!{\tt (vectors y, int K): matrices}|hyperpage}

`matrices` **`cov_matrix_jacobian`**`(vectors y, int K)`<br>\newline
Takes a vector `y` and integer `K`, where `length(y) == K + choose(K, 2)`, and returns
a `K` by `K` covariance matrix.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- vectors; cov_matrix_unconstrain; (matrices x); -->
\index{{\tt \bfseries cov\_matrix\_unconstrain }!{\tt (matrices x): vectors}|hyperpage}

`vectors` **`cov_matrix_unconstrain`**`(matrices x)`<br>\newline
Takes a $K$ by $K$ covariance matrix `x` and returns the corresponding
free vector of size $K + K\choose 2$.
{{< since 2.37 >}}

### Column-stochastic matrices

These functions perform the mathematical transform described in the
[Stochastic Matrix section](https://mc-stan.org/docs/reference-manual/transforms.html#stochastic-matrix-transform.section).

<!-- matrices; stochastic_column_constrain; (matrices y); -->
\index{{\tt \bfseries stochastic\_column\_constrain }!{\tt (matrices y): matrices}|hyperpage}

`matrices` **`stochastic_column_constrain`**`(matrices y)`<br>\newline
Takes a free matrix `y` of size $N$ by $M$ and returns a left stochastic matrix
(a matrix where each column is a simplex) of size $N+1$ by $M$.
{{< since 2.37 >}}

<!-- matrices; stochastic_column_jacobian; (matrices y); -->
\index{{\tt \bfseries stochastic\_column\_jacobian }!{\tt (matrices y): matrices}|hyperpage}

`matrices` **`stochastic_column_jacobian`**`(matrices y)`<br>\newline
Takes a free matrix `y` of size $N$ by $M$ and returns a left stochastic matrix
(a matrix where each column is a simplex) of size $N+1$ by $M$.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- matrices; stochastic_column_unconstrain; (matrices x); -->
\index{{\tt \bfseries stochastic\_column\_unconstrain }!{\tt (matrices x): matrices}|hyperpage}

`matrices` **`stochastic_column_unconstrain`**`(matrices x)`<br>\newline
Takes a left stochastic matrix `x` of size $N+1$ by $M$ and returns the corresponding
free matrix of size $N$ by $M$.
{{< since 2.37 >}}

### Row-stochastic matrices

These functions perform the mathematical transform described in the
[Stochastic Matrix section](https://mc-stan.org/docs/reference-manual/transforms.html#stochastic-matrix-transform.section).

<!-- matrices; stochastic_row_constrain; (matrices y); -->
\index{{\tt \bfseries stochastic\_row\_constrain }!{\tt (matrices y): matrices}|hyperpage}

`matrices` **`stochastic_row_constrain`**`(matrices y)`<br>\newline
Takes a free matrix `y` of size $N$ by $M$ and returns a right stochastic matrix
(a matrix where each row is a simplex) of size $N$ by $M+1$.
{{< since 2.37 >}}

<!-- matrices; stochastic_row_jacobian; (matrices y); -->
\index{{\tt \bfseries stochastic\_row\_jacobian }!{\tt (matrices y): matrices}|hyperpage}

`matrices` **`stochastic_row_jacobian`**`(matrices y)`<br>\newline
Takes a free matrix `y` of size $N$ by $M$ and returns a right stochastic matrix
(a matrix where each row is a simplex) of size $N$ by $M+1$.

This function also increments the `target` variable
with the corresponding change of variables adjustment.
{{< since 2.37 >}}

<!-- matrices; stochastic_row_unconstrain; (matrices x); -->
\index{{\tt \bfseries stochastic\_row\_unconstrain }!{\tt (matrices x): matrices}|hyperpage}

`matrices` **`stochastic_row_unconstrain`**`(matrices x)`<br>\newline
Takes a right stochastic matrix `x` of size $N$ by $M+1$ and returns the corresponding
free matrix of size $N$ by $M$.
{{< since 2.37 >}}
